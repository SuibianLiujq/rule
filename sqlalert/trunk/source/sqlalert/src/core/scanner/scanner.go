// File: scanner.go
//
// This file implements the scanner of base token: string, integer, float and
// scripts. It takes []byte as input text source which can be tokenized throuth
// repeated calls to scanner.Scan() method.
//
// Copyright (C) 2017 YUN Li Lai, Nanjiing, Inc. All Rights Reserved.
// Written by ZHANG Li Dan <lidan.zhang@clearclouds-global.com>.
package scanner

import (
	"errors"
	"fmt"
	"strconv"
	"unicode"
	"unicode/utf8"
)

// BOM - For unicode character checking.
// EOF - End of file.
const (
	BOM = 0xFEFF
	EOF = rune(-1)
)

// Base token generated by scanner.
const (
	T_ILL int = iota
	T_EOF

	T_IDENT
	T_STR
	T_INT
	T_FLOAT
	T_LT
	T_LE
	T_GT
	T_GE
	T_EQ
	T_NE
	T_AND
	T_OR
	T_NOT
	T_INC
	T_DEC
)

// Scanner - Context of scanner.
//
// Scanner holds the internal state of scanner while processing the
// given byte stream. It must be initialized through calling to
// Init() method.
type Scanner struct {
	src  []byte
	Name string

	nOffset  int
	nRead    int
	lastChar rune

	GotError bool
	Error    string
	GotEOF   bool

	LineNum int
	CharNum int
}

// Init() - Initialize the Scanner instance.
//
// @src: Input byte stream.
//
// This function initialize the scanner to tokenize the source text by
// setting the scanner at the begining of src. It returns the instance
// itself for chain operation.
func (this *Scanner) Init(src []byte, name string) (*Scanner, error) {
	this.src = src
	this.Name = name

	this.nOffset = 0
	this.nRead = 0
	this.lastChar = ' '

	this.GotError = false
	this.GotEOF = false
	this.Error = ""

	this.LineNum = 1
	this.CharNum = 0

	this.next()
	if this.lastChar == BOM {
		this.next()
	}

	return this, nil
}

// Scan() - Scan the next token.
//
// This function scan from the next character in the source and returns
// a token.
func (this *Scanner) Scan() (t int, v interface{}) {
	this.skipWhitespace()

	switch ch := this.lastChar; {
	case this.isLetter(ch):
		t, v = T_IDENT, this.scanIdent()

	case this.isDigit(ch):
		t, v = this.scanNumber(false)

	default:
		t, v = this.scanNext(ch)
	}

	return t, v
}

// scanNext() - Next step of scanning a token
//
// @ch: The last read but not consumed characher.
//
// This function scan the tokens depends on more than one character. It returns
// the type and value of the token.
func (this *Scanner) scanNext(ch rune) (t int, v interface{}) {
	switch this.next(); ch {
	case '\'', '"', '`':
		t, v = this.scanString(ch)

	case '*', '/', '%', '?', ':', ';', ',', '.', '$', '(', ')', '[', ']', '{', '}':
		return int(ch), string(ch)

	case '+', '-', '<', '>', '=', '!', '&', '|':
		t, v = this.scanMultiOperator(ch)

	default:
		if ch != BOM && ch != EOF {
			t, v = T_ILL, nil
			this.onError(this.nOffset-1, "illegal character")
		} else {
			t, v = T_EOF, nil
			this.GotEOF = true
		}
	}

	return t, v
}

// scanIdent() - Scan identifier token.
//
// An identifier is a letter and/or digit sequence.
func (this *Scanner) scanIdent() string {
	start := this.nOffset

	for this.isLetter(this.lastChar) || this.isDigit(this.lastChar) {
		this.next()
	}

	return string(this.src[start:this.nOffset])
}

// scanString() - Scan string token.
//
// @quote: The open character of string.
//
// A string, like 'a string' escapes only the onpen character. A mix-used of
// escape open character is not allowed.
func (this *Scanner) scanString(quote rune) (int, string) {
	offset := this.nOffset - 1

	for {
		ch := this.lastChar
		if this.lastChar < 0 {
			this.onError(offset, fmt.Sprintf("expected close quote '%s'", string(quote)))
			return T_ILL, ""
		}

		this.next()
		if ch == quote {
			break
		}

		if ch == '\\' {
			if err := this.scanEscape(quote); err != nil {
				this.onError(offset, fmt.Sprintf("%s", err))
				return T_ILL, ""
			}
		}

		if ch == '\n' {
			this.LineNum++
			this.CharNum = 0
		}
	}

	str, err := strconv.Unquote(string(this.src[offset:this.nOffset]))
	if err != nil {
		return T_STR, string(this.src[offset+1 : this.nOffset-1])
	}

	return T_STR, str
}

// scanEscape() - Scan the escape sequence of the string token.
//
// @quote: Open character of the string.
func (this *Scanner) scanEscape(quote rune) error {
	var n int
	var base, max uint32

	switch this.lastChar {
	case 'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', quote:
		this.next()
		return nil

	case '0', '1', '2', '3', '4', '5', '6', '7':
		n, base, max = 3, 8, 255

	case 'x', 'X':
		this.next()
		n, base, max = 2, 16, 255

	case 'u':
		this.next()
		n, base, max = 4, 16, unicode.MaxRune

	case 'U':
		this.next()
		n, base, max = 8, 16, unicode.MaxRune

	default:
		if this.lastChar < 0 {
			return errors.New("escape not terminated")
		}

		return errors.New("unknown escape sequence")
	}

	return this.scanEscapeNext(n, base, max)
}

// scanEscapeNext() - Next step of scanning escape sequence.
//
// @n:    Number of character needed.
// @base: Base value of each character.
// @max:  Maximum value of the whole sequence.
func (this *Scanner) scanEscapeNext(n int, base, max uint32) error {
	var x uint32 = 0

	for n > 0 {
		d := uint32(this.digitValue(this.lastChar))

		if d >= base {
			if this.lastChar < 0 {
				return errors.New("escape not terminated")
			}

			return errors.New("unknown escape")
		}

		x = x*base + d
		this.next()
		n--
	}

	if x > max || (0xD800 <= x && x < 0xE000) {
		return errors.New("escape invalid unicode")
	}

	return nil
}

// scanNumber() - Scan number token.
//
// @seenPoint: Flag of finding the point of float number.
func (this *Scanner) scanNumber(seenPoint bool) (int, interface{}) {
	offset, token, base := this.nOffset, T_INT, 10

	if seenPoint {
		offset--
		token = T_FLOAT
		this.scanNumberNext(10)
		goto EXPONENT
	}

	if this.lastChar == '0' {
		offset = this.nOffset
		this.next()

		if this.lastChar == 'x' || this.lastChar == 'X' {
			this.next()
			this.scanNumberNext(16)
			base = 16

			if this.nOffset-offset <= 2 {
				this.onError(offset, "illegal HEX number")
				return T_ILL, nil
			}
			offset += 2
		} else {
			seenPoint := false
			this.scanNumberNext(8)
			base = 8

			if this.lastChar == '8' || this.lastChar == '9' {
				seenPoint = true
				this.scanNumberNext(10)
				base = 10
			}

			if this.lastChar == '.' || this.lastChar == 'e' || this.lastChar == 'E' {
				goto FRACTION
			}

			if seenPoint {
				this.onError(offset, "illegal OCTAL number")
				return T_ILL, nil
			}
		}

		goto EXIT
	}

	this.scanNumberNext(10)

FRACTION:
	if this.lastChar == '.' {
		token = T_FLOAT
		this.next()
		this.scanNumberNext(10)
	}

EXPONENT:
	if this.lastChar == 'e' || this.lastChar == 'E' {
		token = T_FLOAT
		this.next()

		if this.lastChar == '-' || this.lastChar == '+' {
			this.next()
		}

		this.scanNumberNext(10)
	}

EXIT:
	value, err := this.parseNumber(token, base, this.src[offset:this.nOffset])
	if err != nil {
		this.onError(offset, fmt.Sprintf("%s", err))
		return T_ILL, nil
	}

	return token, value
}

// scanNumberNext() - Next step of scanning a number.
//
// @base: Base value of number: 8, 10, 16.
func (this *Scanner) scanNumberNext(base int) {
	for this.digitValue(this.lastChar) < base {
		this.next()
	}
}

// scanMultiOperator() - Scan multi-operator tokens.
//
// @ch: The last character (read but not consumed).
//
// This function ruetrns the token type and the token value.
func (this *Scanner) scanMultiOperator(ch rune) (t int, v interface{}) {
	start := this.nOffset - 1

	switch ch {
	case '+':
		if this.lastChar == '+' {
			t = T_INC
			this.next()
		} else {
			t = int(ch)
		}

	case '-':
		if this.lastChar == '-' {
			t = T_DEC
			this.next()
		} else {
			t = int(ch)
		}

	case '<':
		switch this.lastChar {
		case '=':
			this.next()
			t = T_LE
		case '>':
			this.next()
			t = T_NE
		default:
			t = int(ch)
		}

	case '>':
		if this.lastChar == '=' {
			this.next()
			t = T_GE
		} else {
			t = int(ch)
		}

	case '=':
		if this.lastChar == '=' {
			this.next()
			t = T_EQ
		} else {
			t = int(ch)
		}

	case '!':
		if this.lastChar == '=' {
			this.next()
			t = T_NE
		} else {
			t = T_NOT
		}

	case '&':
		if this.lastChar == '&' {
			this.next()
			t = T_AND
		} else {
			this.onError(start, "illegal character")
			return T_ILL, nil
		}

	case '|':
		if this.lastChar == '|' {
			this.next()
			t = T_OR
		} else {
			this.onError(start, "illegal character")
			return T_ILL, nil
		}
	}

	return t, string(this.src[start:this.nOffset])
}

// skipWhitespace() - Skip the whitespace character.
//
// Characters ' ', '\t', '\r' and '\n' are whitespace characters
// and will be skipped.
func (this *Scanner) skipWhitespace() {
	ch := this.lastChar

	for {
		switch ch {
		case ' ', '\t', '\r':
		case '\n':
			this.LineNum++
			this.CharNum = 0
		case '#':
			this.skipComment()
		case '/':
			this.next()
			if this.lastChar == '/' {
				this.skipComment()
			} else {
				this.nRead--
				this.nOffset--
				this.lastChar = ch
				return
			}
		default:
			return
		}

		this.next()
		ch = this.lastChar
	}
}

// skipComment() - Skip comment line(s).
//
// Line start with '#', '//' is a comment line.
func (this *Scanner) skipComment() {
	ch := this.lastChar

	for ch != '\n' && ch != EOF {
		this.next()
		ch = this.lastChar
	}

	this.LineNum++
	this.CharNum = 0
}

// next() - Read next character.
//
// This function reads the next unicode character into this.lastChar.
// It means EOF if this.lastChar < 0.
func (this *Scanner) next() {
	if this.nRead < len(this.src) {
		this.nOffset = this.nRead

		ch, num := rune(this.src[this.nRead]), 1
		switch {
		case ch == 0:
			this.onError(this.nOffset, "illegal character 'nil'")

		case ch < utf8.RuneSelf:
			ch, num := utf8.DecodeRune(this.src[this.nRead:])
			if ch == utf8.RuneError && num == 1 {
				this.onError(this.nOffset, "illegal UTF8 encoding")
			} else if ch == BOM && this.nOffset > 0 {
				this.onError(this.nOffset, "illegal byte order mark")
			}
		}

		this.nRead += num
		this.lastChar = ch
		this.CharNum++
	} else {
		this.nOffset = len(this.src)
		this.lastChar = EOF
		this.GotEOF = true
	}
}

// onError() - Error handler.
//
// @offset: Start position of src.
// @msg:    Error message.
func (this *Scanner) onError(offset int, msg string) {
	this.GotError = true

	if len(this.src[offset:]) > 20 {
		this.Error = fmt.Sprintf("%s '%s...' in line %d", msg, string(this.src[offset:offset+20]), this.LineNum)
	} else {
		this.Error = fmt.Sprintf("%s '%s' in line %d", msg, string(this.src[offset:]), this.LineNum)
	}
}

// isLetter() - Test whether a character is a letter.
//
// @ch: Character to test.
func (this *Scanner) isLetter(ch rune) bool {
	switch {
	case ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z'):
		return true

	default:
		switch ch {
		case '_', '@':
			return true
		}
	}

	return false
}

// isDigit() - Test whether a character is a digital number.
//
// @ch: Character to test.
func (this *Scanner) isDigit(ch rune) bool {
	return '0' <= ch && ch <= '9'
}

// digitValue() - Returns the digit value of the given character.
//
// @ch: The digit character.
//
// This function return the digit value of the digit character and
// default 16 for other invalid digit characters.
func (this *Scanner) digitValue(ch rune) int {
	switch {
	case '0' <= ch && ch <= '9':
		return int(ch - '0')
	case 'a' <= ch && ch <= 'f':
		return int(ch - 'a' + 10)
	case 'A' <= ch && ch <= 'F':
		return int(ch - 'A' + 10)
	}
	return 16
}

// parseNumber() - Parse the number from raw text.
//
// @token: Token type (T_FLOAT or T_INTEGER).
// @base:  Base number of the number to parse.
// @raw:   The raw text.
//
// This function returns the parsed number value (int64 or float64)
// and error info.
func (this *Scanner) parseNumber(token int, base int, raw []byte) (interface{}, error) {
	if token == T_FLOAT {
		v, err := strconv.ParseFloat(string(raw), 64)
		if err != nil {
			return nil, errors.New(fmt.Sprintf("%s in %s", err, string(raw)))
		}
		return v, nil
	}

	v, err := strconv.ParseInt(string(raw), base, 64)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("%s in %s", err, string(raw)))
	}
	return v, nil
}

// New() - New a Scanner instance.
//
// @src: Input bytes stream source.
func New(src []byte, name string) (*Scanner, error) {
	return (&Scanner{}).Init(src, name)
}
